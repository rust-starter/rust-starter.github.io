<!DOCTYPE html>
<html dir="ltr" lang="en-US">
{{> head }}

<body class="terminal">
    <div class="container">

        {{> nav }}

        <p>Create Rust CLI apps with no build configuration.</p>

        <h2 id="what-is">What is rust-starter?</h2>
        <p><code>rust-starter</code> is a template CLI app that compiles. It makes
            choices about depedencies, structure, configuration, error handling,
            logging, CI/CD and more.</p>
        <p>It is useful if you are looking to build a CLI application. It can be used as a starting point for command-line tools that are written in Rust.</p>
        <h2 id="how-to-use">Philosopy</h2>
        <ul>
            <li><strong>Select Depedencies: </strong> <code>rust-starter</code> is
                biased toward popular and stable depedencies. These could be changed later,
                but we make these choices so that you can focus on your CLI functionalities.</li>
            <li><strong>No Configuration: </strong> The <code>rust-starter</code> template
                already compiles and runs, so you don't need to configure anything to get
                your program working.</li>
            <li><strong>Sane Choices: </strong> <code>rust-starter</code> follows the
                <a href="https://github.com/mre/idiomatic-rust">idiomatic Rust</a>                philosophy. It attempts to follow and stick to the industry best
                practices.</li>
            <li><strong>Documentation</strong>: Detailed documentation for the choices, features and possible configurations.
                </li>
        </ul>

        <hr /> {{> toc }}

        <hr />

        <section>
            <header>
                <h2 id="getting-started">Getting Started</h2>
            </header>
            <p>
                <code>rust-starter</code> aims to keep things simple.
                To get started, simply clone the repository, and run the project.
            </p>
            <pre><code>
git clone https://github.com/rust-starter/rust-starter
cd rust-starter
cargo run
                </code></pre>
            <p>
                There are no configurations required and no initial code to write. You should get
                the following output upon running <code>cargo run</code>
            </p>
            <pre><code>
rust-starter 1.0.0
Abid Omar <contact@omarabid.com>
CLI interface

USAGE:
    rust-starter [OPTIONS] [SUBCOMMAND]

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
    -c, --config <FILE>    Set a custom config file

SUBCOMMANDS:
    config    Show Configuration
    error     Simulate an error
    hazard    Generate a hazardous occurance
    help      Prints this message or the help of the given subcommand(s)
</code></pre>
            <p>
                That's it. If you got this output, <code>rust-starter</code> has
                successfully compiled and run. You can also run the available subcommands
                like <code>cargo run config</code> to show the loaded configuration, <code>cargo run hazard</code> which is a sample subcommand, and <code>cargo run error</code> to intentionally trigger an error.
            </p>
        </section>

        <hr />

        <section>
            <header>
                <h2 id="faq">FAQ</h2>
            </header>
            <div class="terminal-card">
                <header>How does rust-starter compare to clap?</header>
                <div>
                    <code>clap</code> and <code>rust-starter</code> do not serve
                    the same purpose. <code>clap</code> is a library to parse command-line arguments. <code>rust-starter</code> is a template program that uses <code>clap</code>.
                </div>
            </div>
            <div class="terminal-card">
                <header>What are some reasons to use rust-starter?</header>
                <div>
                    <ul>
                        <li>To get started quickly.</li>
                        <li>If you want to have CI/CD.</li>
                        <li>If you want to have a good integration with Github and Docker.</li>
                    </ul>
                </div>
            </div>
            <div class="terminal-card">
                <header>What are some reasons <strong>not</strong> to use rust-starter?</header>
                <div>
                    <ul>
                        <li>If you are not building a CLI application.</li>
                    </ul>
                </div>
            </div>
        </section>

        <hr />

        <section>
            <header>
                <h2 id="features">Features</h2>
            </header>

            <section>
                <header>
                    <h3 id="feature-workspaces"><a href="#feature-workspaces">#</a> Workspaces</h3>
                </header>
                <p>
                <code>rust-starter</code> makes use of <a href="https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html">Cargo Workspaces</a> to manage and structure your program. It is possible to have all of the code in a single  workspace and the <code>rust-starter</code> template doesn't need more than one. However, starting this way will help you split code into a separate workspace when you see fit.
                </p>
                <p>
                The main program is inside <code>src</code>. Its main purpose is to start the program, the configuration, logging, and then run the arguments parser. It's not supposed to have any functionality. It is recommended that these are added through Workspaces. <code>rust-starter</code> comes with 3 workspaces.
                </p>
                <ul>

                    <li><strong>cli</strong> : Configure and start Clap.</li>
                    <li><strong>core</strong> : This is where your program code should go.</li>
                    <li><strong>utils</strong> : Various utilities like logging, configuration, errors, etc...</li>
                </ul>
                <p>
                These different workspaces are libraries. It's preferrable that new workspaces can compile on their own. This makes your code modular and unit testing much simpler. You can add more workspaces if you need to.
                </p>
            </section>

            <section>
                <header>
                    <h3 id="feature-clap"><a href="#feature-clap">#</a> Clap</h3>
                </header>
                <p>
                <code>rust-starter</code> uses <a href="https://github.com/clap-rs/clap">clap</a> to parse Command Line arguments. <code>clap</code> is simple, efficient and widely used by the community.
                </p>
                <p>The version used is still in beta (Version 3) but since it has non-backward compatible changes, and several useful upgrades; it might be worthwhile to use the beta until a stable version 3 is released.
                </p>
                <p>
                <code>clap</code> configuration code can be found in <code>cli/src/lib.rs</code>.
                </p>
            </section>

            <section>
                <header>
                    <h3 id="feature-errors"><a href="#feature-errors">#</a> Errors</h3>
                </header>
                <p>
                <code>rust-starter</code> tries to follow the best practices to handle errors. For this, it is useful that your program uses Rust's <code>std::error::Error</code> trait. All your errors should implement this trait. With the 1.0 release, <code>rust-starter</code> uses the <a href="https://github.com/rust-lang-nursery/failure">failure</a> crate; which is now deprecated. <a href="https://github.com/dtolnay/thiserror">thiserror</a> will be used instead in the future; see the note below.
                </p>
                <p>
                To be able to propagate errors using the <code>?</code> operator, it's possible to <a href="https://doc.rust-lang.org/stable/rust-by-example/error/multiple_error_types/boxing_errors.html">wrap your custom error type</a> with a Box type. This has the downside of dynamically allocating memory for errors in the heap. A better approach is to convert errors at compile time; which <code>rust-starter</code> has a few examples of.
                </p>
                <p>
                The approach taken is to define proper <code>Result</code> and <code>Error</code> types. This has the advantage of easy upgrades and library changes. For example, if you want to switch from the <code>thiserror</code> crate, you have a central and single place to do this change, and the rest of your code is unchanged.
                </p>
                <h5>Simulating an error</h5>
                <p>
                To test that our error reporting is functioning correctly, <code>rust-starter</code> has a special subcommand to intentionally trigger an error.
                </p>
                <pre><code>cargo run error</code></pre>
                <p>
                <code>rust-starter</code> uses the <a href="https://github.com/mitsuhiko/better-panic">better-panic</a> crate to print and prettify backtraces. This library is only enabled when debugging and disabled for release builds.
                </p>
                <p class="terminal-alert terminal-alert-error">
                Backtracing for the <code>std::Error</code> is only available in nightly. For this reason, the stable <code>rust-starter</code> still uses the <a href="https://crates.io/crates/failure">Failure</a> crate. If you want to use <code>std::Error</code> with Backtrace in nightly, use the <code>newError</code> branch.
                </p>
            </section>

            <section>
                <header>
                    <h3 id="feature-configuration"><a href="#feature-configuration">#</a> Configuration</h3>
                </header>
                <p>
                <code>rust-starter</code> manages a configuration struct to mutate, store and retrieve a configuration state. Currently, a configuration file could be passed using the <code>-c</code> flag, and its content will be merged. Environment variables starting with <code>APP</code> will also be merged. It's recommended to change the <code>APP</code> prefix.
                </p>
                <p>
                Under the hood, <code>rust-starter</code> uses the <a href="https://github.com/mehcode/config-rs">config-rs</a> crate. However, it exposes an <code>AppConfig</code> struct that you can use to store and retrieve configuration. The relevant code can be found in <code>utils/src/app_config.rs</code>. It's recommended to use this struct instead of <code>config-rs</code> directly, as this depedency might get changed in the future.
                </p>
                <p>
                The configuration struct is initialized with a default configuration file at program start. This file can be found in <code>src/resources/default_config.toml</code>. You only need to initialize the configuration once. It's stored in a static <a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html">RwLock</a> making it globally accessible and also thread-safe.
                </p>
                <pre><code>
    let config_contents = include_str!("resources/default_config.toml");
    AppConfig::init(Some(config_contents))?;
                </code></pre>
                <p>
                You can merge additional settings to your configuration struct, but also retrieve or change single settings.
                </p>
                <pre><code>
    // Merge config
    AppConfig::merge_config(cli_matches.value_of("config"))?;
    // Get config value
    AppConfig::get::<bool>("debug").unwrap();
    // Set config value
    AppConfig::set("database.url", "new url").unwrap();</code></pre>
            </section>

            <section>
                <header>
                    <h3 id="feature-logging"><a href="#feature-logging">#</a> Logging</h3>
                </header>
                <p>
                The standard interface for logging in Rust is the <a href="https://github.com/rust-lang/log">log</a> crate. It defines a set of macros for logging like <code>info!</code> and <code>error!</code>. While <code>rust-starter</code> uses <a href="https://github.com/slog-rs/slog">slog</a> and has two drains for logs: syslog and terminal; it is fully compatible with the log facade.
                </p>
                <p>
                Logging in <code>rust-starter</code> works out of the box. In any of the sub-crates in your workspace, you can add the log crate as a depedency and use its macros. These logs will be forwarded to slog drains. If these drains are not available or fail to initialize, the logs will be discarded.
                </p>
                <p>
                To see logging in action, you can run the <code>error</code> command. It should log an error message to the terminal and syslog. Before the program fails, you should see this line. (This should also be logged to syslog).
                </p>
                <pre><code>Nov 10 01:19:42.014 INFO We are simulating an error, who: rust-starter</code></pre>
                <p>
                While this is good enough, you might want to customize your logging drains. Any logs that you write, are passed to all of these drains. slog supports several drain options. The file <code>utils/src/logger.rs</code> contains these implementations.
                </p>
            </section>

            <section>
                <header>
                    <h3 id="feature-testing"><a href="#feature-testing">#</a> Testing</h3>
                </header>
                <p>
                <code>rust-starter</code> comes with a few tests for the commandline program and the config struct. You can run all the tests by running.
                </p>
                <pre><code>cargo test --all</code></pre>
                <p>
                It is recommended to put integration tests for the command line in the root of your program, and write tests for each sub-crate in your workspace individually.
                </p>
                <p>
                <code>rust-starter</code> also has integrations to run tests in Github actions, and also a code coverage integration with <a href="https://codecov.io">codecov</a>.
                </p>
            </section>

            <section>
                <header>
                    <h3 id="feature-cicd"><a href="#feature-cicd">#</a> CI/CD</h3>
                </header>
                <p>
                <code>rust-starter</code> is not optimized for any particular use-case; and should, preferrably, run in multiple operating systems under different conditions. Unfortunately, it's currently compiled only against Linux. macOS and Windows are high in the list of the OSes to be supported in the next releases.
                </p>
                <p>
                Currently, <code>rust-starter</code> compiles under <a href="https://github.com/emk/rust-musl-builder">rust-musl-builder</a>. <code>rust-musl-builder</code> is a docker image to compile your rust application into a static Rust binary. It is then tested under Alpine Linux to make sure your program is working inside the lightest of containers.
                </p>
                <p>
                While compiling locally is faster for development, this doesn't give many garantuees about your program running under different conditions. This is less important if you are deploying your program to a predictable environment (ie: a server). You can, then, change the Docker file to match the environment for your deployment. 
                </p>
                <p>
                On the other hand, if you are distributing the program under different conditions as a binary, it might be a good idea to have it compile as a static standalone binary. To do that, all you have to run is the compile command for that. You'll need to have <a href="https://www.docker.com/">Docker</a> and <a href="https://github.com/casey/just">just</a> installed in your system.
                </p>
                <pre><code>just build-image</code></pre>
                <p>
                There is no output for this build process, although it's possible to tweak that. The reason is that the build happens over Github when you push your code. For that, see the next section Github actions.
                </p>
            </section>

            <section>
                <header>
                    <h3 id="feature-github"><a href="#feature-github">#</a> Github Actions</h3>
                </header>
                <p>
                Several workflows are included. This is a list
                </p>
                <ul>
                    <li><span><strong>audit.yml</strong></span>: runs a security audit check and generate a report.</li>
                    <li><span><strong>build.yml</strong></span>: build your project and upload the artifact as a release.</li>
                    <li><span><strong>codecov.yml</strong></span>: run codecov and upload coverage report.</li>
                    <li><span><strong>lint.yml</strong></span>: run clippy and generate a lint report.</li>
                    <li><span><strong>tests.yml</strong></span>: run tests on github actions.</li>
                    <li><span><strong>toc.yml</strong></span>: This generate a Table of Content for the Readme page, and could be removed.</li>
                    </ul>
            </section>

            <section>
                <header>
                    <h3 id="feature-generate"><a href="#feature-generate">#</a> Cargo Generate</h3>
                </header>
                <p>
                <a href="https://github.com/ashleygwilliams/cargo-generate">cargo-generate</a> is a developer tool to help you get up and running quickly with a new Rust project by leveraging a pre-existing git repository as a template. cargo-generate doesn't have any templates by default and <code>rust-stater</code> has a template. A template for rust-starter is available at <a href="https://github.com/rust-starter/rust-starter-generate">rust-starter-generate</a>.
                </p>
                <pre><code>cargo generate --git https://github.com/rust-starter/rust-starter-generate</code></pre>
            </section>

        </section>

        <hr />

        <section>
            <header>
                <h2 id="contributing">Contributing</h2>
            </header>
            <p>
                We welcome any kind of contributions. Whether you are reporting a bug, coding a
                feature or correcting a typo. Every effort counts; and all contributions
                are greatly appreaciated.
            </p>
            <p>
                Details on how to contribute can be found in <a href="https://github.com/rust-starter/rust-starter/blob/master/.github/CONTRIBUTING.md">CONTRIBUTING.md</a>.
            </p>
        </section>

        <hr />

        <section>
            <header>
                <h2 id="license">License</h2>
            </header>
            <p>
                rust-starter is licensed under the <a href="https://github.com/rust-starter/rust-starter/blob/master/LICENSE">MIT License</a>.
                Dependent libraries and crates have their own license. An analyze
                of licensing for these libraries is still under-work.
            </p>
            <p>
                The logo is sourced from <a href="https://www.flaticon.com/free-icon/nitrous-oxide_2906152">Flaticon</a>.
            </p>
        </section>

        <hr />

        <section>
            <header>
                <h2 id="author">Author</h2>
            </header>
            <p>
                <code>rust-starter</code> is built and maintained by <a href="https://omarabid.com">Abid Omar</a>.
                You can reach me at <a href="mailto:ruststarter@omarabid.com">ruststarter@omarabid.com</a>.
            </p>
        </section>
    </div>
    {{> footer }}
</body>

</html>
